"""
461.汉明距离
两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
给你两个整数 x 和 y，计算并返回它们之间的汉明距离。
解题思路：内置位计数功能（python没有）；移位实现计数；Brian Kernighan 算法
    本题只是191.位1的个数的变形
计算 xx 和 yy 之间的汉明距离，可以先计算 x⊕y，然后统计结果中等于 11 的位数。
现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。
"""
class Solution(object):
    def hammingDistance(self, x, y):
        """
        :type x: int
        :type y: int
        :rtype: int
        移位实现计数
        我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一
        然后我们令 s 整体右移一位这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。
        我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。
        时间击败95.89%，内存击败43.84%
        """
        n, result = x^y, 0
        while n:
            result += 1 if n & 1 else 0
            n = n >> 1
        return result

    def hammingDistance1(self, x, y):
        """
        :type x: int
        :type y: int
        :rtype: int
        Brian Kernighan 算法
        在方法二中，对于 s=(10001100)2的情况，我们需要循环右移 8 次才能得到答案。
        而实际上如果我们可以跳过两个 1 之间的 0，直接对 1 进行计数，那么就只需要循环 3 次即可。
        我们可以使用 Brian Kernighan 算法进行优化，
            具体地，该算法可以被描述为这样一个结论：记 f(x) 表示 x 和 x−1 进行与运算所得的结果（即 f(x)=x & (x−1)）
            那么 f(x) 恰为 x 删去其二进制表示中最右侧的 1 的结果。
        基于该算法，当我们计算出 s=x⊕y，只需要不断让 s=f(s)，直到 s=0 即可。
        这样每循环一次，s 都会删去其二进制表示中最右侧的 1，最终循环的次数即为 s 的二进制表示中 1 的数量。
        时间击败87.51%，内存击败8.22%
        """
        n, result = x^y, 0
        while n:
            n = n & (n-1)
            result += 1
        return result