"""
1838.最高频元素的频数
元素的 频数 是该元素在一个数组中出现的次数。
给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。
执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。
解题思路：排序 + 滑动窗口
提示 1
    操作后的最高频元素必定可以是数组中已有的某一个元素。
提示 1 解释
    我们用 xi 来表示 nums 数组中下标为 i 的元素。
    如果可以将数组内的一系列元素 xi1,...,xik 全部变为 y，假设这些元素中的最大值为 xx，那么我们一定可以将这些数全部变成 x，此时频数不变且操作次数更少。
提示 2
    优先操作距离目标值最近的（小于目标值的）元素。
提示 2 解释
    假设目标值为 y，对于数组内任意两个小于 y 的元素 xi < xj
    将较大者（xj）变为 y 所需要的操作数为 y - xj
    而对应改变较小者（xi）做需要的操作数为 y - xi
    显然有 y - xj < y - xiy−x
提示 3
    遍历数组中的每个元素作为目标值并进行尝试。
    此处是否存在一些可以用于优化算法的性质？

思路与算法
    我们可以按照提示 1 与提示 2 的贪心策略进行操作。
    将数组排序，遍历排序后数组每个元素 xr作为目标值，并求出此时按贪心策略可以改变至目标值的元素左边界。
    此时考虑到数据范围为 10^5，朴素的线性查找显然会超时，因此需要寻找可以优化的性质。
    我们可以枚举 xr 作为目标值。假设 xr对应的答案左边界为 xl
    定义 Δ(l,r) 为将 xl,…,xr全部变为 xr所需要的操作次数：
             i=l              i=l
    Δ(l,r) = ∑(xr−xi)=(r−l)xr​−∑xi
              r               r−1
    考虑右边界 rr 右移至 r + 1r+1 的过程，此时：
    Δ(l,r+1)-Δ(l,r) = (xr+1-xr)(r-l+1) >= 0
    操作数有可能超过限制 k，因此在超过限制的情况下，我们需要移动左边界 l。
    同样考虑左边界 l 右移至 l+1 的过程，此时:
    Δ(l+1,r+1)−Δ(l,r+1) = −(xr+1−xl) ≤ 0.
    这说明右移左边界会使得答案减小，因此我们需要移动左边界直至对应的 Δ(l′,r+1) 不大于 k。
我们使用 l 与 r 作为执行操作的左右边界（闭区间），同时用 total 来维护将 [l,r] 区间全部变为末尾元素的操作次数。
在顺序枚举目标值（右边界）的同时，我们更新对应的左边界，并用 res 来维护满足限制的最大区间元素数量即可。
另外要注意，此处 total 有可能会超过 32 位整数的范围，因此在 C++ 等语言中需要使用更高位数的整型变量( long 等)。
"""
"""
:type nums: List[int]
:type k: int
:rtype: int
"""


class Solution(object):
    def maxFrequency(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        时间击败78%，内存击败49%
        """
        nums.sort()
        result = 1
        length = len(nums)
        l = 0
        total = 0
        for r in range(1, length):
            total += (nums[r] - nums[r - 1]) * (r - l)
            while total > k:
                total -= nums[r] - nums[l]
                l += 1
            result = max(result, r - l + 1)
        return result
