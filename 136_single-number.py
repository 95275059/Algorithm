#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
136.只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。
    1.使用集合存储数字。
    遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。
    2.使用哈希表存储每个数字和该数字出现的次数。
    遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。
    3.使用集合存储数组中出现的所有数字，并计算数组中的元素之和。
    由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。
    由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。
上述三种解法都需要额外使用 O(n)O(n) 的空间，其中 nn 是数组长度。
如何才能做到线性时间复杂度和常数空间复杂度呢？
答案是使用位运算。对于这道题，可使用异或运算⊕。
异或运算有以下三个性质。
    1.任何数和0做异或运算，结果仍然是原来的数，即 a⊕0=a。
    2.任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
    3.异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。
假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。
令A1,A2,...,Am为出现两次的m个数，Am+1为出现一次的数
根据异或运算的性质，数组中的全部元素的异或运算结果总是可以写成: (A1⊕A1)⊕(A2⊕A2)⊕...⊕(Am⊕Am)⊕Am+1 = 0⊕0⊕...⊕Am+1 = Am+1
因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。
"""
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        排序后遍历
        时间击败30.49%，内存击败83.65%
        但排序就不是线性时间复杂度了
        """
        nums.sort()
        if len(nums) == 1:
            return nums[0]
        i = 0
        while i < len(nums)-1:
            if nums[i] == nums[i+1]:
                i += 2
            else:
                return nums[i]
        return nums[i]

    def singleNumber1(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        异或运算
        时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。
        空间复杂度：O(1)。
        时间击败41.44%，内存击败56.55%
        """
        result = 0
        for n in nums:
            result = result ^ n
        return result

if __name__ == '__main__':
    solution = Solution()
    nums = [2,2,1]
    nums = [4,1,2,1,2]
    result = solution.singleNumber1(nums)
    print(result)