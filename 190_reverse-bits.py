"""
190.颠倒二进制位
颠倒给定的 32 位无符号整数的二进制位。
提示：
    请注意，在某些语言（如 Java）中，没有无符号整数类型。
        在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
    在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
进阶:
    如果多次调用这个函数，你将如何优化你的算法？
解题思路：逐位颠倒；位运算分治
"""
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        """
        :param n:
        :return:
        逐位颠倒
        将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。
        代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。
        需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。
        时间击败96.65%，内存击败13.72%
        """
        i, result = 0, 0
        while i < 32 and n:
            result |= (n & 1) << (31-i)
            i += 1
            n >>= 1
        return result

    def reverseBits2(self, n):
        """
        :param n:
        :return:
        位运算分治
        若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。
        由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。
        对于递归的最底层，我们需要交换所有奇偶位：
            取出所有奇数位和偶数位；
            将奇数位移到偶数位上，偶数位移到奇数位上。
        类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。
        需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。
        顺序无所谓 16,8,4,2,1 和 1,2,4,8,16都可以
        时间击败71.65%，内存击败39.02%
        """
        n = ((n & 0xFFFF0000) >> 16) | ((n & 0x0000FFFF) << 16)
        n = ((n & 0xFF00FF00) >> 8) | ((n & 0x00FF00FF) << 8)
        n = ((n & 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4)
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2)
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1)
        return n