"""
1877.数组中最大数对和的最小值
一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。
比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。
给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得：
    nums 中每个元素 恰好 在 一个 数对中，且最大数对和 的值 最小 。
请你在最优数对划分的方案下，返回最小的 最大数对和 。
解题思路：排序+贪心
提示 1
    数组内只有两个数的情况是平凡的。
    我们可以考虑数组中只有四个数 x1≤x2≤x3≤x4的情况。
    此时 (x1,x4),(x2,x3) 的拆分方法对应的最大数对和一定是最小的。
提示 1 解释
    我们可以枚举所有的拆分方法。除了上文的拆分方法外还有两种拆分方法：
    1. (x1,x3), (x2,x4)
    此时，x2+x4 >= x1+x4 且 x2+x4 >= x2+x3
    那么 max(x1+x3, x2+x4) >= x2+x4 >= max(x1+x4, x2+x3)
    2. (x1,x2), (x3,x4)
    同样的 max(x1+x2, x3+x4) >= x3+x4 >= max(x1+x4, x2+x3)
提示 2
    对于 n 个数（n为偶数）的情况，上述的条件对应的拆分方法，即第 k 大与第 k 小组成的 n/2 个数对，同样可以使得最大数对和最小。
"""
class Solution(object):
    def minPairSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        时间击败98.65%，内存击败83.78%
        """
        nums.sort()
        i, j = 0, len(nums)-1
        result = float('-INF')
        while i<j:
            result = max(result, nums[i]+nums[j])
            i += 1
            j -= 1
        return result